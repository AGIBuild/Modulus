@using Modulus.UI.Abstractions

<MudNavMenu Bordered="true" Color="Color.Primary">
    @foreach (var item in Items)
    {
        @if (item.Children != null && item.Children.Count > 0)
        {
            <!-- Hierarchical item with children -->
            <MudNavGroup Title="@(IsMini ? "" : item.DisplayName)" 
                         Icon="@GetIcon(item.Icon.ToString())" 
                         Expanded="@item.IsExpanded"
                         ExpandedChanged="@(expanded => OnExpandedChanged(item, expanded))"
                         Disabled="@(!item.IsEnabled)">
                @foreach (var child in item.Children)
                {
                    <MudTooltip Text="@child.DisplayName" Placement="Placement.Right" Disabled="@(!IsMini)">
                        <MudNavLink Href="@child.NavigationKey" 
                                    Icon="@GetIcon(child.Icon.ToString())" 
                                    Match="NavLinkMatch.Prefix"
                                    Disabled="@(!child.IsEnabled)"
                                    OnClick="@(() => OnItemClick(child))">
                            @if (!IsMini)
                            {
                                <div class="nav-item-content">
                                    <span>@child.DisplayName</span>
                                    @if (child.BadgeCount.HasValue && child.BadgeCount > 0)
                                    {
                                        <MudBadge Content="@child.BadgeCount" 
                                                  Color="@GetBadgeColor(child.BadgeColor)" 
                                                  Overlap="false"
                                                  Class="nav-badge" />
                                    }
                                </div>
                            }
                            else if (child.BadgeCount.HasValue && child.BadgeCount > 0)
                            {
                                <MudBadge Dot="true" Color="@GetBadgeColor(child.BadgeColor)" Overlap="true" />
                            }
                        </MudNavLink>
                    </MudTooltip>
                }
            </MudNavGroup>
        }
        else
        {
            <!-- Leaf item -->
            <MudTooltip Text="@item.DisplayName" Placement="Placement.Right" Disabled="@(!IsMini)">
                <MudNavLink Href="@item.NavigationKey" 
                            Icon="@GetIcon(item.Icon.ToString())" 
                            Match="NavLinkMatch.Prefix"
                            Disabled="@(!item.IsEnabled)"
                            OnClick="@(() => OnItemClick(item))">
                    @if (!IsMini)
                    {
                        <div class="nav-item-content">
                            <span>@item.DisplayName</span>
                            @if (item.BadgeCount.HasValue && item.BadgeCount > 0)
                            {
                                <MudBadge Content="@item.BadgeCount" 
                                          Color="@GetBadgeColor(item.BadgeColor)" 
                                          Overlap="false"
                                          Class="nav-badge" />
                            }
                        </div>
                    }
                    else if (item.BadgeCount.HasValue && item.BadgeCount > 0)
                    {
                        <MudBadge Dot="true" Color="@GetBadgeColor(item.BadgeColor)" Overlap="true" />
                    }
                </MudNavLink>
            </MudTooltip>
        }
    }
</MudNavMenu>

<style>
    .nav-item-content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
    }
    
    .nav-badge {
        margin-left: auto;
    }
</style>

@code {
    [Parameter]
    public IEnumerable<MenuItem> Items { get; set; } = Enumerable.Empty<MenuItem>();

    /// <summary>
    /// When true, shows only icons (for mini drawer mode).
    /// </summary>
    [Parameter]
    public bool IsMini { get; set; }

    /// <summary>
    /// Callback when an item is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<MenuItem> OnItemClicked { get; set; }

    private async Task OnItemClick(MenuItem item)
    {
        if (!item.IsEnabled || string.IsNullOrEmpty(item.NavigationKey))
        {
            return;
        }

        await OnItemClicked.InvokeAsync(item);
    }

    private void OnExpandedChanged(MenuItem item, bool expanded)
    {
        item.IsExpanded = expanded;
    }

    private string GetIcon(string iconName)
    {
        return iconName?.ToLower() switch
        {
            "extension" or "modules" => Icons.Material.Filled.Extension,
            "settings" or "gear" => Icons.Material.Filled.Settings,
            "home" => Icons.Material.Filled.Home,
            "note" or "notes" => Icons.Material.Filled.Note,
            "echo" or "voice" => Icons.Material.Filled.RecordVoiceOver,
            "dashboard" => Icons.Material.Filled.Dashboard,
            "person" or "user" => Icons.Material.Filled.Person,
            "search" => Icons.Material.Filled.Search,
            "info" => Icons.Material.Filled.Info,
            "help" => Icons.Material.Filled.Help,
            "folder" => Icons.Material.Filled.Folder,
            "file" => Icons.Material.Filled.InsertDriveFile,
            "code" => Icons.Material.Filled.Code,
            "chat" => Icons.Material.Filled.Chat,
            "mail" or "email" => Icons.Material.Filled.Mail,
            "calendar" => Icons.Material.Filled.CalendarMonth,
            "star" => Icons.Material.Filled.Star,
            "favorite" or "heart" => Icons.Material.Filled.Favorite,
            "group" or "category" => Icons.Material.Filled.Category,
            "list" => Icons.Material.Filled.List,
            "notifications" or "bell" => Icons.Material.Filled.Notifications,
            "palette" or "components" => Icons.Material.Filled.Palette,
            _ => Icons.Material.Filled.Circle
        };
    }

    private Color GetBadgeColor(string? colorName)
    {
        return colorName?.ToLower() switch
        {
            "error" or "red" => Color.Error,
            "warning" or "orange" => Color.Warning,
            "info" or "blue" => Color.Info,
            "success" or "green" => Color.Success,
            "primary" => Color.Primary,
            "secondary" => Color.Secondary,
            _ => Color.Error
        };
    }
}

